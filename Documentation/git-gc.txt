git-gc(1)
=========

NAME
----
git-gc - Cleanup unnecessary files and optimize the local repository


SYNOPSIS
--------
[verse]
'git gc' [--aggressive] [--auto] [--quiet] [--prune=<date> | --no-prune] [--force] [--keep-largest-pack]

DESCRIPTION
-----------
Runs a number of housekeeping tasks within the current repository,
such as compressing file revisions (to reduce disk space and increase
performance), removing unreachable objects which may have been
created from prior invocations of 'git add', packing refs, pruning
reflog, rerere metadata or stale working trees. May also update ancillary
indexes such as the commit-graph.

Most users should not have to run this command manually. When common
porcelain operations that create objects are run, such as
linkgit:git-commit[1] and linkgit:git-fetch[1], `git gc --auto` will
be run automatically.

You should only need to run `git gc` manually when adding objects to a
repository without regularly running such porcelain commands. Another
use-case is wanting to do a one-off repository optimization.

If you know what you're doing and want to disable automatic runs, do:

----------------------
$ git config --global gc.auto 0
----------------------

OPTIONS
-------

--aggressive::
	Usually 'git gc' runs very quickly while providing good disk
	space utilization and performance.  This option will cause
	'git gc' to more aggressively optimize the repository to save storage space
	at the expense of taking much more time.
+
Using this option may optimize for disk space at the expense of
runtime performance. See the `--depth` and `--window` documentation in
linkgit:git-repack[1]. It is not recommended that this option be used
to improve performance for a given repository without running tailored
performance benchmarks on it. It may make things better, or worse. Not
using this at all is the right trade-off for most users and their
repositories.
+
The effects of this option are persistent to the extent that
`gc.autoPackLimit` and friends don't cause a consolidation of existing
pack(s) generated with this option.

--auto::
	With this option, 'git gc' checks whether any housekeeping is
	required; if not, it exits without performing any work.
+
See the `gc.auto' option in the "CONFIGURATION" below for how this
heuristic works.
+
Once housekeeping is triggered by exceeding the limits of
configurations options such as `gc.auto` and `gc.autoPackLimit`, all
other housekeeping tasks (e.g. rerere, working trees, reflog...) will
be performed as well.


--prune=<date>::
	Prune loose objects older than date (default is 2 weeks ago,
	overridable by the config variable `gc.pruneExpire`).
	--prune=now prunes loose objects regardless of their age and
	increases the risk of corruption if another process is writing to
	the repository concurrently; see "NOTES" below. --prune is on by
	default.

--no-prune::
	Do not prune any loose objects.

--quiet::
	Suppress all progress reports.

--force::
	Force `git gc` to run even if there may be another `git gc`
	instance running on this repository.

--keep-largest-pack::
	All packs except the largest pack and those marked with a
	`.keep` files are consolidated into a single pack. When this
	option is used, `gc.bigPackThreshold` is ignored.

CONFIGURATION
-------------

The below documentation is the same as what's found in
linkgit:git-config[1]:

include::config/gc.txt[]

NOTES
-----

'git gc' tries very hard not to delete objects that are referenced
anywhere in your repository. In
particular, it will keep not only objects referenced by your current set
of branches and tags, but also objects referenced by the index,
remote-tracking branches, refs saved by 'git filter-branch' in
refs/original/, or reflogs (which may reference commits in branches
that were later amended or rewound).
If you are expecting some objects to be deleted and they aren't, check
all of those locations and decide whether it makes sense in your case to
remove those references.

On the other hand, when 'git gc' runs concurrently with another process,
there is a risk of it deleting an object that the other process is using
but hasn't created a reference to. This may just cause the other process
to fail or may corrupt the repository if the other process later adds a
reference to the deleted object. Git has two features that significantly
mitigate this problem:

. Any object with modification time newer than the `--prune` date is kept,
  along with everything reachable from it.

. Most operations that add an object to the database update the
  modification time of the object if it is already present so that #1
  applies.

However, these features fall short of a complete solution, so users who
run commands concurrently have to live with some risk of corruption (which
seems to be low in practice) unless they turn off automatic garbage
collection with 'git config gc.auto 0'.

HOOKS
-----

The 'git gc --auto' command will run the 'pre-auto-gc' hook.  See
linkgit:githooks[5] for more information.


SEE ALSO
--------
linkgit:git-prune[1]
linkgit:git-reflog[1]
linkgit:git-repack[1]
linkgit:git-rerere[1]

GIT
---
Part of the linkgit:git[1] suite
